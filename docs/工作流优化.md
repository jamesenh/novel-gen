# å·¥ä½œæµä¼˜åŒ–è®¡åˆ’

## æ¦‚è¿°

æœ¬æ–‡æ¡£è®°å½• NovelGen é¡¹ç›®åç»­çš„å·¥ä½œæµä¼˜åŒ–æ–¹å‘ï¼ŒæŒ‰ä¼˜å…ˆçº§æ’åºã€‚

---

## ä¼˜åŒ–ç‚¹ 1: åŠ¨æ€ç« èŠ‚æ•°é‡ï¼ˆP0 - é«˜ä¼˜å…ˆçº§ï¼‰âœ… å·²å®Œæˆ

### å½“å‰é—®é¢˜

å¤§çº²ç”Ÿæˆæ—¶é€šè¿‡ `settings.num_chapters` å›ºå®šç« èŠ‚æ•°é‡ï¼Œé•¿ç¯‡å°è¯´æ— æ³•æ ¹æ®å‰§æƒ…å‘å±•åŠ¨æ€è°ƒæ•´ç« èŠ‚ã€‚

### å®Œæˆç›®æ ‡

1. æ”¯æŒåˆ†é˜¶æ®µè§„åˆ’ï¼šåˆå§‹åªè§„åˆ’å¼€ç¯‡ç« èŠ‚ï¼Œåç»­æ ¹æ®å‰§æƒ…è¿›åº¦åŠ¨æ€æ‰©å±•
2. LLM å¯åˆ¤æ–­ã€Œæ•…äº‹æ˜¯å¦è¯¥ç»“æŸã€ï¼Œè‡ªåŠ¨è§¦å‘ç»“å±€ç« èŠ‚ç”Ÿæˆ
3. ä¿æŒä¸ç°æœ‰æ£€æŸ¥ç‚¹/æ–­ç‚¹ç»­è·‘æœºåˆ¶çš„å…¼å®¹æ€§

### å®ç°ç»†èŠ‚

**æ–¹æ¡ˆ A: åˆ†é˜¶æ®µè§„åˆ’ï¼ˆæ¨èï¼‰**

- ä¿®æ”¹ `outline_creation_node`ï¼Œåˆå§‹åªç”Ÿæˆã€Œå¼€ç¯‡ + å‘å±•ã€é˜¶æ®µï¼ˆ3-5 ç« ï¼‰
- æ–°å¢ `evaluate_story_progress_node` èŠ‚ç‚¹ï¼Œæ¯éš” N ç« è¯„ä¼°å‰§æƒ…è¿›åº¦
- æ–°å¢ `extend_outline_node` èŠ‚ç‚¹ï¼ŒåŸºäºå½“å‰å‰§æƒ…ç”Ÿæˆåç»­ç« èŠ‚å¤§çº²
- å½“è¯„ä¼°ç»“æœä¸ºã€Œå¯ä»¥æ”¶å°¾ã€æ—¶ï¼Œç”Ÿæˆã€Œé«˜æ½® + ç»“å±€ã€ç« èŠ‚

**çŠ¶æ€æ¨¡å‹å˜æ›´**

- `Outline` æ·»åŠ  `is_complete: bool` å­—æ®µæ ‡è®°å¤§çº²æ˜¯å¦å®Œæ•´
- `Settings` çš„ `num_chapters` æ”¹ä¸º `initial_chapters`ï¼ˆåˆå§‹è§„åˆ’ç« èŠ‚æ•°ï¼‰
- æ–°å¢ `max_chapters: int` å­—æ®µé˜²æ­¢æ— é™ç”Ÿæˆ

**å‰§æƒ…è¿›åº¦è¯„ä¼°é€»è¾‘**

`evaluate_story_progress_node` éœ€è¦ç»¼åˆè€ƒè™‘ `max_chapters` å’Œå½“å‰ç« èŠ‚æ•°ï¼š

| æ¡ä»¶ | è¯„ä¼°ç»“æœ | åç»­åŠ¨ä½œ |
|------|----------|----------|
| å½“å‰ç« èŠ‚ >= max_chapters | å¼ºåˆ¶æ”¶å°¾ | ç”Ÿæˆç»“å±€å¤§çº²ï¼ˆ1-2 ç« ï¼‰ |
| å½“å‰ç« èŠ‚ >= max_chapters * 0.8 | å»ºè®®æ”¶å°¾ | LLM è¯„ä¼°æ˜¯å¦å¯ä»¥è‡ªç„¶æ”¶å°¾ |
| å½“å‰ç« èŠ‚ < max_chapters * 0.8 | æ­£å¸¸è¯„ä¼° | LLM è‡ªä¸»åˆ¤æ–­ç»§ç»­/æ”¶å°¾ |

LLM è¯„ä¼°æ—¶çš„ prompt éœ€åŒ…å«ï¼š
- å‰©ä½™å¯ç”¨ç« èŠ‚æ•°ï¼š`max_chapters - current_chapter`
- ä¸»çº¿å‰§æƒ…å®Œæˆåº¦ï¼ˆåŸºäºå¤§çº²ä¸­çš„æ ¸å¿ƒå†²çªè§£å†³è¿›åº¦ï¼‰
- æœªè§£å†³çš„ä¼ç¬”/æ”¯çº¿æ•°é‡
- å»ºè®®ï¼šå‰©ä½™ç« èŠ‚ä¸è¶³æ—¶ï¼Œä¼˜å…ˆæ”¶æŸæ”¯çº¿ï¼Œèšç„¦ä¸»çº¿

**å·¥ä½œæµå˜æ›´**

åœ¨ `next_chapter_node` åæ·»åŠ æ¡ä»¶åˆ†æ”¯ï¼š
- è‹¥å½“å‰ç« èŠ‚ >= å·²è§„åˆ’ç« èŠ‚æ•° ä¸” å¤§çº²æœªå®Œæˆ â†’ `evaluate_story_progress_node`
- è¯„ä¼°ç»“æœä¸ºã€Œç»§ç»­ã€â†’ `extend_outline_node` â†’ `chapter_planning_node`
- è¯„ä¼°ç»“æœä¸ºã€Œæ”¶å°¾ã€â†’ ç”Ÿæˆç»“å±€å¤§çº² â†’ ç»§ç»­ç« èŠ‚ç”Ÿæˆ
- è¯„ä¼°ç»“æœä¸ºã€Œå¼ºåˆ¶æ”¶å°¾ã€â†’ ç”Ÿæˆå‹ç¼©ç‰ˆç»“å±€å¤§çº²ï¼ˆå¿«é€Ÿæ”¶æŸæ‰€æœ‰æ”¯çº¿ï¼‰

---

## ä¼˜åŒ–ç‚¹ 2: åœºæ™¯ç”Ÿæˆå­å·¥ä½œæµï¼ˆP1 - ä¸­é«˜ä¼˜å…ˆçº§ï¼‰âœ… å·²å®Œæˆ

### å½“å‰é—®é¢˜

`chapter_generation_node` åœ¨å•ä¸ªèŠ‚ç‚¹å†…å¾ªç¯å¤„ç†æ‰€æœ‰åœºæ™¯ï¼š

```python
# å½“å‰å®ç°ï¼ˆnodes.py 710-836è¡Œï¼‰
generated_scenes = []
for scene_plan in plan.scenes:
    scene = generate_scene_text(...)
    generated_scenes.append(scene)  # åªåœ¨å†…å­˜ä¸­ç´¯ç§¯
    _save_scene_to_mem0(...)        # ä¿å­˜åˆ° Mem0ï¼Œä½†ä¸ä¿å­˜æ–‡ä»¶

# åªæœ‰å…¨éƒ¨å®Œæˆåæ‰ä¿å­˜åˆ°æ–‡ä»¶
chapter = GeneratedChapter(scenes=generated_scenes, ...)
with open(chapter_path, 'w') as f:
    json.dump(chapter.model_dump(), f, ...)
```

**é—®é¢˜**ï¼š
1. é€»è¾‘å†—é•¿ï¼Œéš¾ä»¥ç»´æŠ¤
2. æ— æ³•å®ç°åœºæ™¯çº§æ–­ç‚¹ç»­è·‘
3. å¦‚æœç”Ÿæˆç¬¬3ä¸ªåœºæ™¯æ—¶å¤±è´¥ï¼Œå‰2ä¸ªåœºæ™¯çš„æ–‡æœ¬ä¸¢å¤±ï¼Œéœ€è¦é‡æ–°ç”Ÿæˆ

### å®Œæˆç›®æ ‡

1. å°†åœºæ™¯ç”Ÿæˆæ‹†åˆ†ä¸ºç‹¬ç«‹çš„ LangGraph å­å·¥ä½œæµ
2. æ”¯æŒåœºæ™¯çº§åˆ«çš„æ£€æŸ¥ç‚¹ï¼Œä¸­æ–­åå¯ä»å…·ä½“åœºæ™¯æ¢å¤
3. æ¯ä¸ªåœºæ™¯å®Œæˆåç«‹å³æŒä¹…åŒ–åˆ°æ–‡ä»¶
4. ä¸ºåç»­ã€Œåœºæ™¯çº§ä¸€è‡´æ€§æ£€æµ‹ã€å’Œã€Œåœºæ™¯çº§ä¿®è®¢ã€åšå‡†å¤‡

### å®ç°ç»†èŠ‚

#### 1. å­å·¥ä½œæµç»“æ„

```
scene_generation_subgraph
â”‚
â”œâ”€â”€ init_scene_loop          # åˆå§‹åŒ–ï¼šè®¾ç½® current_scene_numberï¼Œæ£€æµ‹å·²å­˜åœ¨åœºæ™¯
â”‚   â””â”€â”€ [æ¡ä»¶è¾¹] should_generate_scene
â”‚           â”œâ”€â”€ "skip"    â†’ next_scene_node
â”‚           â””â”€â”€ "execute" â†’ retrieve_memory_node
â”‚
â”œâ”€â”€ retrieve_memory_node     # ä» Mem0 æ£€ç´¢è§’è‰²çŠ¶æ€å’Œç›¸å…³è®°å¿†
â”‚   â””â”€â”€ generate_scene_node
â”‚
â”œâ”€â”€ generate_scene_node      # è°ƒç”¨ LLM ç”Ÿæˆåœºæ™¯æ–‡æœ¬
â”‚   â””â”€â”€ save_scene_node
â”‚
â”œâ”€â”€ save_scene_node          # ä¿å­˜åœºæ™¯åˆ°æ–‡ä»¶å’Œ Mem0
â”‚   â””â”€â”€ next_scene_node
â”‚
â”œâ”€â”€ next_scene_node          # é€’å¢ current_scene_number
â”‚   â””â”€â”€ [æ¡ä»¶è¾¹] has_more_scenes
â”‚           â”œâ”€â”€ "continue" â†’ [æ¡ä»¶è¾¹] should_generate_scene
â”‚           â””â”€â”€ "end"      â†’ END
â”‚
â””â”€â”€ END                      # è¿”å›å®Œæ•´çš„ generated_scenes
```

#### 2. çŠ¶æ€æ¨¡å‹è®¾è®¡ï¼ˆå…³é”®ï¼‰

**âš ï¸ é‡è¦ï¼šå­å›¾åº”ä½¿ç”¨ç‹¬ç«‹çš„çŠ¶æ€ç±»å‹ï¼Œä¸æ±¡æŸ“çˆ¶å›¾çŠ¶æ€**

æ ¹æ® LangGraph æœ€ä½³å®è·µï¼Œçˆ¶å›¾å’Œå­å›¾ä½¿ç”¨ä¸åŒçš„çŠ¶æ€ç±»å‹ï¼š

```python
# models.py æ–°å¢

class SceneGenerationState(BaseModel):
    """åœºæ™¯ç”Ÿæˆå­å·¥ä½œæµçŠ¶æ€
    
    ç‹¬ç«‹äº NovelGenerationStateï¼Œç”¨äºåœºæ™¯çº§åˆ«çš„æ£€æŸ¥ç‚¹å’Œæ–­ç‚¹ç»­è·‘
    """
    # ç« èŠ‚ä¿¡æ¯
    chapter_number: int = Field(description="å½“å‰ç« èŠ‚ç¼–å·")
    chapter_plan: ChapterPlan = Field(description="ç« èŠ‚è®¡åˆ’")
    
    # åœºæ™¯å¾ªç¯æ§åˆ¶
    current_scene_number: int = Field(default=1, description="å½“å‰åœºæ™¯ç¼–å·ï¼ˆä»1å¼€å§‹ï¼‰")
    total_scenes: int = Field(default=0, description="æ€»åœºæ™¯æ•°")
    generated_scenes: List[GeneratedScene] = Field(
        default_factory=list, 
        description="å·²ç”Ÿæˆçš„åœºæ™¯åˆ—è¡¨"
    )
    scene_status: Dict[int, str] = Field(
        default_factory=dict,
        description="åœºæ™¯çŠ¶æ€: pending/generating/completed/failed"
    )
    
    # ä¸Šä¸‹æ–‡ä¼ é€’
    previous_summary: str = Field(default="", description="å‰ä¸€åœºæ™¯æ‘˜è¦ï¼Œç”¨äºè¡”æ¥")
    scene_memory_context: Optional[SceneMemoryContext] = Field(
        default=None, 
        description="å½“å‰åœºæ™¯çš„è®°å¿†ä¸Šä¸‹æ–‡"
    )
    
    # ä»çˆ¶å›¾ä¼ å…¥çš„åªè¯»ä¸Šä¸‹æ–‡ï¼ˆå¿…é¡»æœ‰é»˜è®¤å€¼ä»¥å…¼å®¹ model_constructï¼‰
    world: Optional[WorldSetting] = Field(default=None, description="ä¸–ç•Œè§‚è®¾å®š")
    characters: Optional[CharactersConfig] = Field(default=None, description="è§’è‰²é…ç½®")
    project_dir: str = Field(default="", description="é¡¹ç›®ç›®å½•")
    project_name: str = Field(default="", description="é¡¹ç›®åç§°")
    verbose: bool = Field(default=False, description="è¯¦ç»†æ—¥å¿—")
```

**âš ï¸ Pydantic å…¼å®¹æ€§è¦æ±‚**ï¼š

LangGraph æ›´æ–°çŠ¶æ€æ—¶å¯èƒ½ä½¿ç”¨ `model_construct` ç»•è¿‡éªŒè¯ï¼Œå› æ­¤ï¼š
- æ‰€æœ‰å­—æ®µå¿…é¡»æœ‰é»˜è®¤å€¼ï¼ˆ`default` æˆ– `default_factory`ï¼‰
- å¯é€‰å­—æ®µä½¿ç”¨ `Optional[T] = None`

#### 3. æ£€æŸ¥ç‚¹ç®¡ç†ï¼ˆå…³é”®ï¼‰

**âŒ é”™è¯¯åšæ³•**ï¼šå­å·¥ä½œæµä½¿ç”¨ç‹¬ç«‹çš„ `SqliteSaver`

**âœ… æ­£ç¡®åšæ³•**ï¼šçˆ¶å›¾å’Œå­å›¾å…±ç”¨åŒä¸€ä¸ª checkpointer

æ ¹æ® LangGraph æ–‡æ¡£ï¼Œæ£€æŸ¥ç‚¹ä¼š**è‡ªåŠ¨ä»çˆ¶å›¾ä¼ æ’­åˆ°å­å›¾**ï¼š

```python
# workflow.py

# çˆ¶å›¾å®šä¹‰
parent_builder = StateGraph(NovelGenerationState)
parent_builder.add_node("chapter_generation", scene_generation_wrapper_node)
# ... å…¶ä»–èŠ‚ç‚¹

# å­å›¾å®šä¹‰ï¼ˆä¸è®¾ç½® checkpointerï¼‰
scene_builder = StateGraph(SceneGenerationState)
scene_builder.add_node("init_scene_loop", init_scene_loop_node)
# ... å…¶ä»–èŠ‚ç‚¹
scene_subgraph = scene_builder.compile()  # ä¸ä¼  checkpointer

# çˆ¶å›¾ç¼–è¯‘æ—¶è®¾ç½® checkpointerï¼Œä¼šè‡ªåŠ¨ä¼ æ’­åˆ°å­å›¾
checkpointer = SqliteSaver(conn)
parent_graph = parent_builder.compile(checkpointer=checkpointer)
```

#### 4. çˆ¶å­å›¾çŠ¶æ€è½¬æ¢

éœ€è¦ä¸€ä¸ª**åŒ…è£…èŠ‚ç‚¹**å¤„ç† `NovelGenerationState` â†” `SceneGenerationState` çš„è½¬æ¢ï¼š

```python
# nodes.py

def scene_generation_wrapper_node(state: NovelGenerationState) -> Dict[str, Any]:
    """
    åŒ…è£…èŠ‚ç‚¹ï¼šè°ƒç”¨åœºæ™¯ç”Ÿæˆå­å·¥ä½œæµ
    
    èŒè´£ï¼š
    1. ä»çˆ¶å›¾çŠ¶æ€æå–å­å›¾è¾“å…¥
    2. æ£€æŸ¥å·²å­˜åœ¨çš„åœºæ™¯æ–‡ä»¶ï¼ˆæ–­ç‚¹ç»­è·‘ï¼‰
    3. è°ƒç”¨å­å›¾
    4. å°†å­å›¾ç»“æœåˆå¹¶å›çˆ¶å›¾çŠ¶æ€
    """
    chapter_number = state.current_chapter_number
    plan = state.chapters_plan[chapter_number]
    chapters_dir = os.path.join(state.project_dir, "chapters")
    
    # 1. æ„å»ºå­å›¾è¾“å…¥çŠ¶æ€
    subgraph_input = SceneGenerationState(
        chapter_number=chapter_number,
        chapter_plan=plan,
        total_scenes=len(plan.scenes),
        world=state.world,
        characters=state.characters,
        project_dir=state.project_dir,
        project_name=state.project_name,
        verbose=state.verbose
    )
    
    # 2. æ£€æŸ¥å·²å­˜åœ¨çš„åœºæ™¯æ–‡ä»¶ï¼ˆæ–­ç‚¹ç»­è·‘æ”¯æŒï¼‰
    for scene_plan in plan.scenes:
        scene_file = os.path.join(
            chapters_dir,
            f"scene_{chapter_number:03d}_{scene_plan.scene_number:03d}.json"
        )
        if os.path.exists(scene_file):
            with open(scene_file, 'r', encoding='utf-8') as f:
                scene = GeneratedScene(**json.load(f))
            subgraph_input.generated_scenes.append(scene)
            subgraph_input.scene_status[scene_plan.scene_number] = "completed"
            print(f"  â­ï¸ åœºæ™¯ {scene_plan.scene_number} å·²å­˜åœ¨ï¼Œè·³è¿‡")
    
    # è®¾ç½®èµ·å§‹åœºæ™¯ç¼–å·
    subgraph_input.current_scene_number = len(subgraph_input.generated_scenes) + 1
    
    # 3. è°ƒç”¨å­å›¾
    result = scene_generation_subgraph.invoke(subgraph_input)
    
    # 4. åˆå¹¶åœºæ™¯ä¸ºç« èŠ‚
    chapter = GeneratedChapter(
        chapter_number=chapter_number,
        chapter_title=plan.chapter_title,
        scenes=result.generated_scenes,
        total_words=sum(s.word_count for s in result.generated_scenes)
    )
    
    # 5. ä¿å­˜å®Œæ•´ç« èŠ‚æ–‡ä»¶
    chapter_file = os.path.join(chapters_dir, f"chapter_{chapter_number:03d}.json")
    with open(chapter_file, 'w', encoding='utf-8') as f:
        json.dump(chapter.model_dump(), f, ensure_ascii=False, indent=2)
    
    # 6. æ¸…ç†å•ç‹¬çš„åœºæ™¯æ–‡ä»¶ï¼ˆå¯é€‰ï¼‰
    # for scene in result.generated_scenes:
    #     scene_file = os.path.join(chapters_dir, f"scene_{chapter_number:03d}_{scene.scene_number:03d}.json")
    #     if os.path.exists(scene_file):
    #         os.remove(scene_file)
    
    chapters = dict(state.chapters)
    chapters[chapter_number] = chapter
    
    return {
        "chapters": chapters,
        "current_step": "chapter_generation",
        "completed_steps": state.completed_steps + [f"chapter_generation_{chapter_number}"]
    }
```

#### 5. åœºæ™¯æŒä¹…åŒ–ç­–ç•¥

**æ¯ä¸ªåœºæ™¯å®Œæˆåç«‹å³ä¿å­˜åˆ°æ–‡ä»¶**ï¼š

```python
# nodes.py - å­å›¾èŠ‚ç‚¹

def save_scene_node(state: SceneGenerationState) -> Dict[str, Any]:
    """ä¿å­˜åœºæ™¯åˆ°æ–‡ä»¶å’Œ Mem0"""
    scene = state.generated_scenes[-1]
    chapters_dir = os.path.join(state.project_dir, "chapters")
    os.makedirs(chapters_dir, exist_ok=True)
    
    # 1. ä¿å­˜åœºæ™¯ JSON æ–‡ä»¶
    scene_file = os.path.join(
        chapters_dir,
        f"scene_{state.chapter_number:03d}_{scene.scene_number:03d}.json"
    )
    with open(scene_file, 'w', encoding='utf-8') as f:
        json.dump(scene.model_dump(), f, ensure_ascii=False, indent=2)
    print(f"  ğŸ’¾ åœºæ™¯ {scene.scene_number} å·²ä¿å­˜: {scene_file}")
    
    # 2. ä¿å­˜åˆ° Mem0
    mem0_manager = _get_mem0_manager(state.project_dir, state.project_name)
    if mem0_manager:
        _save_scene_to_mem0(
            mem0_manager=mem0_manager,
            content=scene.content,
            chapter_number=state.chapter_number,
            scene_number=scene.scene_number
        )
    
    # 3. æ›´æ–°åœºæ™¯çŠ¶æ€
    scene_status = dict(state.scene_status)
    scene_status[scene.scene_number] = "completed"
    
    return {"scene_status": scene_status}
```

**æ–‡ä»¶ç»“æ„**ï¼š

```
projects/demo_001/chapters/
â”œâ”€â”€ scene_001_001.json      # ç¬¬1ç« åœºæ™¯1ï¼ˆä¸­é—´æ–‡ä»¶ï¼Œç« èŠ‚å®Œæˆåå¯åˆ é™¤ï¼‰
â”œâ”€â”€ scene_001_002.json      # ç¬¬1ç« åœºæ™¯2
â”œâ”€â”€ scene_001_003.json      # ç¬¬1ç« åœºæ™¯3
â”œâ”€â”€ chapter_001.json        # å®Œæ•´ç¬¬1ç« ï¼ˆåˆå¹¶æ‰€æœ‰åœºæ™¯ï¼‰
â”œâ”€â”€ chapter_001_plan.json   # ç¬¬1ç« è®¡åˆ’
â””â”€â”€ ...
```

#### 6. å­å›¾èŠ‚ç‚¹å®ç°

```python
# nodes.py - å­å›¾èŠ‚ç‚¹

def init_scene_loop_node(state: SceneGenerationState) -> Dict[str, Any]:
    """åˆå§‹åŒ–åœºæ™¯å¾ªç¯"""
    print(f"ğŸ“ å¼€å§‹ç”Ÿæˆç¬¬ {state.chapter_number} ç« çš„åœºæ™¯...")
    print(f"   æ€»åœºæ™¯æ•°: {state.total_scenes}, å·²å®Œæˆ: {len(state.generated_scenes)}")
    
    return {
        "current_scene_number": len(state.generated_scenes) + 1
    }


def should_generate_scene(state: SceneGenerationState) -> Literal["skip", "execute"]:
    """æ¡ä»¶å‡½æ•°ï¼šåˆ¤æ–­å½“å‰åœºæ™¯æ˜¯å¦éœ€è¦ç”Ÿæˆ"""
    scene_num = state.current_scene_number
    
    if scene_num in state.scene_status and state.scene_status[scene_num] == "completed":
        return "skip"
    return "execute"


def retrieve_memory_node(state: SceneGenerationState) -> Dict[str, Any]:
    """ä» Mem0 æ£€ç´¢è®°å¿†ä¸Šä¸‹æ–‡"""
    scene_num = state.current_scene_number
    scene_plan = state.chapter_plan.scenes[scene_num - 1]  # ç´¢å¼•ä»0å¼€å§‹
    
    mem0_manager = _get_mem0_manager(state.project_dir, state.project_name)
    scene_memory_context = _retrieve_scene_memory_context(
        mem0_manager=mem0_manager,
        scene_plan=scene_plan,
        chapter_number=state.chapter_number,
        project_name=state.project_name
    )
    
    return {"scene_memory_context": scene_memory_context}


def generate_scene_node(state: SceneGenerationState) -> Dict[str, Any]:
    """ç”Ÿæˆåœºæ™¯æ–‡æœ¬"""
    scene_num = state.current_scene_number
    scene_plan = state.chapter_plan.scenes[scene_num - 1]
    
    print(f"  âœï¸ ç”Ÿæˆåœºæ™¯ {scene_num}...")
    
    scene = generate_scene_text(
        scene_plan=scene_plan,
        world_setting=state.world,
        characters=state.characters,
        previous_summary=state.previous_summary,
        chapter_context="",
        scene_memory_context=state.scene_memory_context,
        verbose=state.verbose
    )
    
    # æ›´æ–° previous_summary ç”¨äºä¸‹ä¸€åœºæ™¯
    new_summary = scene.content[:200] + "..." if len(scene.content) > 200 else scene.content
    
    return {
        "generated_scenes": state.generated_scenes + [scene],
        "previous_summary": new_summary
    }


def next_scene_node(state: SceneGenerationState) -> Dict[str, Any]:
    """é€’å¢åœºæ™¯ç¼–å·"""
    return {
        "current_scene_number": state.current_scene_number + 1
    }


def has_more_scenes(state: SceneGenerationState) -> Literal["continue", "end"]:
    """æ¡ä»¶å‡½æ•°ï¼šåˆ¤æ–­æ˜¯å¦è¿˜æœ‰æ›´å¤šåœºæ™¯"""
    if state.current_scene_number <= state.total_scenes:
        return "continue"
    return "end"
```

#### 7. å­å›¾å®šä¹‰

```python
# workflow.py

def create_scene_generation_subgraph():
    """åˆ›å»ºåœºæ™¯ç”Ÿæˆå­å·¥ä½œæµ"""
    from langgraph.graph import StateGraph, START, END
    from novelgen.models import SceneGenerationState
    
    builder = StateGraph(SceneGenerationState)
    
    # æ·»åŠ èŠ‚ç‚¹
    builder.add_node("init_scene_loop", init_scene_loop_node)
    builder.add_node("retrieve_memory", retrieve_memory_node)
    builder.add_node("generate_scene", generate_scene_node)
    builder.add_node("save_scene", save_scene_node)
    builder.add_node("next_scene", next_scene_node)
    builder.add_node("skip_scene", lambda s: {})  # ç©ºæ“ä½œ
    
    # å®šä¹‰è¾¹
    builder.add_edge(START, "init_scene_loop")
    
    builder.add_conditional_edges(
        "init_scene_loop",
        should_generate_scene,
        {"skip": "skip_scene", "execute": "retrieve_memory"}
    )
    
    builder.add_edge("retrieve_memory", "generate_scene")
    builder.add_edge("generate_scene", "save_scene")
    builder.add_edge("save_scene", "next_scene")
    builder.add_edge("skip_scene", "next_scene")
    
    builder.add_conditional_edges(
        "next_scene",
        has_more_scenes,
        {"continue": "init_scene_loop", "end": END}  # æ³¨æ„ï¼šå›åˆ° init ä»¥è§¦å‘æ¡ä»¶åˆ¤æ–­
    )
    
    # æ³¨æ„ï¼šä¸ä¼  checkpointerï¼Œç”±çˆ¶å›¾ä¼ æ’­
    return builder.compile()

scene_generation_subgraph = create_scene_generation_subgraph()
```

#### 8. æ–­ç‚¹ç»­è·‘éªŒè¯

**åœºæ™¯ Aï¼šä¸­é€”ä¸­æ–­åæ¢å¤**

1. ç”Ÿæˆåœºæ™¯1 â†’ ä¿å­˜ `scene_001_001.json`
2. ç”Ÿæˆåœºæ™¯2 â†’ ä¿å­˜ `scene_001_002.json`
3. ç”Ÿæˆåœºæ™¯3 æ—¶ä¸­æ–­ âŒ
4. æ¢å¤è¿è¡Œ â†’ æ£€æµ‹åˆ°åœºæ™¯1ã€2å·²å­˜åœ¨ â†’ è·³è¿‡
5. ç»§ç»­ä»åœºæ™¯3ç”Ÿæˆ âœ…

**åœºæ™¯ Bï¼šå®Œå…¨ä»å¤´è¿è¡Œ**

1. æ— åœºæ™¯æ–‡ä»¶ â†’ `current_scene_number = 1`
2. ä¾æ¬¡ç”Ÿæˆæ‰€æœ‰åœºæ™¯

---

## ä¼˜åŒ–ç‚¹ 3: åœºæ™¯å¹¶è¡Œç”Ÿæˆï¼ˆP1 - ä¸­é«˜ä¼˜å…ˆçº§ï¼‰

### å½“å‰é—®é¢˜

åœºæ™¯æŒ‰é¡ºåºä¸²è¡Œç”Ÿæˆï¼Œæ¯ç«  4-6 ä¸ªåœºæ™¯æ—¶ç”Ÿæˆæ—¶é—´è¾ƒé•¿ã€‚

### å®Œæˆç›®æ ‡

1. æ”¯æŒåŒä¸€ç« èŠ‚å†…å¤šä¸ªåœºæ™¯å¹¶è¡Œç”Ÿæˆï¼ˆé…ç½®åŒ–å¼€å…³ï¼‰
2. å¹¶è¡Œç”Ÿæˆåè‡ªåŠ¨æ‹¼æ¥ï¼Œç¡®ä¿åœºæ™¯è¡”æ¥è‡ªç„¶
3. æä¾›åœºæ™¯ä¾èµ–å£°æ˜æœºåˆ¶ï¼Œä¾èµ–åœºæ™¯ä¸²è¡Œï¼Œç‹¬ç«‹åœºæ™¯å¹¶è¡Œ

### å®ç°ç»†èŠ‚

**å‰ç½®ä¾èµ–**ï¼šéœ€å…ˆå®Œæˆä¼˜åŒ–ç‚¹2ï¼ˆåœºæ™¯ç”Ÿæˆå­å·¥ä½œæµï¼‰

**å¹¶è¡Œç­–ç•¥**

- åˆ†æåœºæ™¯è®¡åˆ’ä¸­çš„ `characters` å’Œ `location` å­—æ®µ
- è‹¥ä¸¤ä¸ªåœºæ™¯æ— å…±åŒè§’è‰²ä¸”åœ°ç‚¹ä¸åŒï¼Œå¯å¹¶è¡Œç”Ÿæˆ
- å¦åˆ™æŒ‰é¡ºåºä¸²è¡Œç”Ÿæˆ

**LangGraph å®ç°**

- ä½¿ç”¨æ¡ä»¶è¾¹åŠ¨æ€å†³å®šå¹¶è¡Œ/ä¸²è¡Œè·¯å¾„
- å¹¶è¡Œåˆ†æ”¯ä½¿ç”¨ `fanout` æ¨¡å¼ï¼Œæ¯ä¸ªåˆ†æ”¯ç”Ÿæˆä¸€ä¸ªåœºæ™¯
- æ±‡èšåæ‰§è¡Œ `merge_scenes_node` æ£€æŸ¥è¡”æ¥ä¸€è‡´æ€§

**åå¤„ç†**

- æ–°å¢ `scene_coherence_check_node` æ£€æŸ¥å¹¶è¡Œåœºæ™¯çš„è¡”æ¥
- è‹¥å‘ç°å†²çªï¼ˆå¦‚æ—¶é—´çº¿çŸ›ç›¾ï¼‰ï¼Œè§¦å‘å±€éƒ¨ä¿®è®¢
- é…ç½®é¡¹ `parallel_scene_generation: bool` æ§åˆ¶æ˜¯å¦å¯ç”¨

**é£é™©ä¸é™åˆ¶**

- å¹¶è¡Œç”Ÿæˆçš„åœºæ™¯å¯èƒ½å­˜åœ¨ç»†èŠ‚å†²çªï¼Œéœ€è¦åå¤„ç†ä¿®å¤
- API å¹¶å‘è°ƒç”¨é‡å¢åŠ ï¼Œéœ€æ³¨æ„ Rate Limit
- å»ºè®®åˆæœŸä»…å¯¹ã€Œç‹¬ç«‹æ€§é«˜ã€çš„åœºæ™¯å¯ç”¨å¹¶è¡Œ

---

## ä¼˜åŒ–ç‚¹ 4: Function Call æŒ‰éœ€æ£€ç´¢ï¼ˆP2 - ä¸­ä¼˜å…ˆçº§ï¼‰

### å½“å‰é—®é¢˜

åœºæ™¯ç”Ÿæˆå‰é¢„å…ˆæ£€ç´¢æ‰€æœ‰å¯èƒ½ç›¸å…³çš„ Mem0 ä¸Šä¸‹æ–‡ï¼Œå¯èƒ½è¿‡åº¦æ£€ç´¢æˆ–é—æ¼å…³é”®ä¿¡æ¯ã€‚

### å®Œæˆç›®æ ‡

1. LLM åœ¨ç”Ÿæˆè¿‡ç¨‹ä¸­å¯è‡ªä¸»è°ƒç”¨ä¸Šä¸‹æ–‡æ£€ç´¢å·¥å…·
2. å‡å°‘ prompt é•¿åº¦ï¼Œåªæ³¨å…¥çœŸæ­£éœ€è¦çš„ä¿¡æ¯
3. ä¸ºåç»­ Agent æ¨¡å¼æ‰©å±•æ‰“åŸºç¡€

### å®ç°ç»†èŠ‚

**Tool å®šä¹‰**

å®šä¹‰ä»¥ä¸‹ LangChain Tools ä¾› LLM è°ƒç”¨ï¼š

- `get_character_state(name: str)` - è·å–æŒ‡å®šè§’è‰²å½“å‰çŠ¶æ€
- `search_related_events(query: str)` - æœç´¢ç›¸å…³å‰§æƒ…äº‹ä»¶
- `get_location_info(location: str)` - è·å–åœ°ç‚¹è¯¦ç»†ä¿¡æ¯
- `get_chapter_summary(chapter_num: int)` - è·å–æŒ‡å®šç« èŠ‚æ‘˜è¦

**è°ƒç”¨æ§åˆ¶**

- è®¾ç½® `max_tool_calls: int = 5` é™åˆ¶å•æ¬¡ç”Ÿæˆçš„æœ€å¤§è°ƒç”¨æ¬¡æ•°
- Tool è¿”å›ç»“æœè‡ªåŠ¨æ³¨å…¥åˆ°åç»­ prompt ä¸­
- ä½¿ç”¨ `create_react_agent` æˆ– `AgentExecutor` ç®¡ç†è°ƒç”¨å¾ªç¯

**æˆæœ¬è€ƒé‡**

- Function Call ä¼šå¢åŠ  API è°ƒç”¨æ¬¡æ•°å’Œ token æ¶ˆè€—
- å»ºè®®é€šè¿‡é…ç½®é¡¹ `use_function_call_retrieval: bool` æ§åˆ¶
- çŸ­ç¯‡å°è¯´å¯å…³é—­æ­¤åŠŸèƒ½ï¼Œé•¿ç¯‡å°è¯´è®°å¿†åº“å¤§æ—¶å¯ç”¨

**å®ç°æ­¥éª¤**

1. åœ¨ `scene_text_chain.py` ä¸­åˆ›å»º Tool ç»‘å®šç‰ˆæœ¬çš„ chain
2. ä¿®æ”¹ `generate_scene_text` å‡½æ•°æ”¯æŒ Agent æ¨¡å¼
3. åœ¨ `nodes.py` ä¸­æ ¹æ®é…ç½®é€‰æ‹©è°ƒç”¨å“ªä¸ªç‰ˆæœ¬

---

## ä¼˜å…ˆçº§æ€»ç»“

| åºå· | ä¼˜åŒ–ç‚¹ | ä¼˜å…ˆçº§ | é¢„ä¼°å·¥ä½œé‡ | ä¾èµ–å…³ç³» | çŠ¶æ€ |
|------|--------|--------|-----------|----------|------|
| 1 | åŠ¨æ€ç« èŠ‚æ•°é‡ | P0 | 3-5 å¤© | æ—  | âœ… å·²å®Œæˆ |
| 2 | åœºæ™¯ç”Ÿæˆå­å·¥ä½œæµ | P1 | 3-4 å¤© | æ—  | âœ… å·²å®Œæˆ |
| 3 | åœºæ™¯å¹¶è¡Œç”Ÿæˆ | P1 | 2-3 å¤© | ä¾èµ–ä¼˜åŒ–ç‚¹ 2 | ğŸ”² å¾…å¼€å§‹ |
| 4 | Function Call æŒ‰éœ€æ£€ç´¢ | P2 | 2-3 å¤© | æ—  | ğŸ”² å¾…å¼€å§‹ |

---

## åç»­æ‰©å±•æ–¹å‘ï¼ˆå¾…è¯„ä¼°ï¼‰

- **åˆ†å±‚è®°å¿†æ¶æ„**ï¼šçŸ­æœŸ/ä¸­æœŸ/é•¿æœŸè®°å¿†åˆ†ç¦»ï¼Œä¼˜åŒ–é•¿ç¯‡å°è¯´çš„æ£€ç´¢æ•ˆç‡
- **åœºæ™¯çº§ä¸€è‡´æ€§æ£€æµ‹**ï¼šåœ¨åœºæ™¯ç”Ÿæˆåç«‹å³æ£€æµ‹ï¼Œè€Œéç­‰æ•´ç« å®Œæˆ
- **å¤šæ¨¡å‹åä½œ**ï¼šä¸åŒæ­¥éª¤ä½¿ç”¨ä¸åŒæ¨¡å‹ï¼ˆå¦‚ GPT-4 åšè§„åˆ’ï¼ŒGPT-3.5 åšç”Ÿæˆï¼‰

---

## æŠ€æœ¯è¦ç‚¹å¤‡å¿˜

### LangGraph å­å›¾é›†æˆ

1. **æ£€æŸ¥ç‚¹ä¼ æ’­**ï¼šçˆ¶å›¾çš„ checkpointer ä¼šè‡ªåŠ¨ä¼ æ’­åˆ°å­å›¾ï¼Œæ— éœ€å•ç‹¬é…ç½®
2. **çŠ¶æ€éš”ç¦»**ï¼šå­å›¾ä½¿ç”¨ç‹¬ç«‹çš„çŠ¶æ€ç±»å‹ï¼Œé¿å…æ±¡æŸ“çˆ¶å›¾çŠ¶æ€
3. **çŠ¶æ€è½¬æ¢**ï¼šé€šè¿‡åŒ…è£…èŠ‚ç‚¹å¤„ç†çˆ¶å­å›¾çŠ¶æ€çš„è½¬æ¢
4. **Command.PARENT**ï¼šå­å›¾èŠ‚ç‚¹å¯ä½¿ç”¨ `Command(graph=Command.PARENT)` è¿”å›çˆ¶å›¾

### Pydantic å…¼å®¹æ€§

1. æ‰€æœ‰çŠ¶æ€å­—æ®µå¿…é¡»æœ‰é»˜è®¤å€¼ï¼ˆ`default` æˆ– `default_factory`ï¼‰
2. å¯é€‰å­—æ®µä½¿ç”¨ `Optional[T] = None` è€Œéè£¸ç±»å‹
3. LangGraph å¯èƒ½ä½¿ç”¨ `model_construct` è·³è¿‡éªŒè¯ï¼Œé¿å…ä¾èµ–éªŒè¯å™¨çš„å‰¯ä½œç”¨

---

## å®æ–½è®°å½•ï¼šé€’å½’é™åˆ¶é¢„ä¼°æœºåˆ¶ (2025-11-30)

### é—®é¢˜èƒŒæ™¯

åœ¨é•¿ç¯‡å°è¯´ç”Ÿæˆè¿‡ç¨‹ä¸­é‡åˆ°ä»¥ä¸‹é—®é¢˜ï¼š

1. **GraphRecursionError**ï¼šLangGraph é»˜è®¤é€’å½’é™åˆ¶ 25 æ¬¡ï¼Œä¸è¶³ä»¥å®Œæˆå¤šç« èŠ‚ç”Ÿæˆ
2. **æ£€æŸ¥ç‚¹ä¸ä¸€è‡´**ï¼šé€’å½’é”™è¯¯å¯¼è‡´å¼‚å¸¸é€€å‡ºï¼Œæ£€æŸ¥ç‚¹æœªæ­£ç¡®ä¿å­˜
3. **ç¨‹åºå¡é¡¿**ï¼šChromaDB åå°çº¿ç¨‹å¯¼è‡´ç¨‹åºé€€å‡ºæ—¶å¡é¡¿ 3 åˆ†é’Ÿ

### è§£å†³æ–¹æ¡ˆ

#### 1. é€’å½’é™åˆ¶é¢„ä¼°æœºåˆ¶

**æ ¸å¿ƒæ€è·¯**ï¼šè‡ªç»´æŠ¤èŠ‚ç‚¹æ‰§è¡Œè®¡æ•°ï¼Œåœ¨å‰©ä½™æ¬¡æ•°ä¸è¶³å®Œæˆä¸‹ä¸€ç« æ—¶ä¸»åŠ¨åœæ­¢ã€‚

**ä¿®æ”¹çš„æ–‡ä»¶ï¼š**
- `novelgen/models.py` - æ·»åŠ æ–°å­—æ®µ
- `novelgen/runtime/workflow.py` - ç¯å¢ƒå˜é‡è¯»å–å’Œæ¡ä»¶è¾¹é€»è¾‘
- `novelgen/runtime/nodes.py` - æ¯ä¸ªèŠ‚ç‚¹æ›´æ–°è®¡æ•°
- `novelgen/runtime/orchestrator.py` - åˆå§‹åŒ–é…ç½®

**æ–°å¢çŠ¶æ€å­—æ®µï¼ˆNovelGenerationStateï¼‰ï¼š**
```python
node_execution_count: int = Field(default=0, description="èŠ‚ç‚¹æ‰§è¡Œè®¡æ•°")
recursion_limit: int = Field(default=500, description="é€’å½’é™åˆ¶")
should_stop_early: bool = Field(default=False, description="æ˜¯å¦ä¸»åŠ¨åœæ­¢")
```

**ç¯å¢ƒå˜é‡é…ç½®ï¼š**
```bash
# é€’å½’é™åˆ¶ï¼ˆé»˜è®¤ 500ï¼Œè¶³å¤Ÿç”Ÿæˆ 80+ ç« ï¼‰
LANGGRAPH_RECURSION_LIMIT=500

# æ¯ç« é¢„ä¼°æ¶ˆè€—èŠ‚ç‚¹æ•°ï¼ˆé»˜è®¤ 6ï¼‰
LANGGRAPH_NODES_PER_CHAPTER=6
```

**æ¡ä»¶è¾¹é¢„ä¼°é€»è¾‘ï¼ˆshould_evaluate_or_continue å‡½æ•°ï¼‰ï¼š**
```python
remaining_steps = state.recursion_limit - state.node_execution_count
if remaining_steps < ESTIMATED_NODES_PER_CHAPTER:
    print(f"âš ï¸ å‰©ä½™é€’å½’æ¬¡æ•°({remaining_steps}) < æ¯ç« æ‰€éœ€({ESTIMATED_NODES_PER_CHAPTER})ï¼Œä¸»åŠ¨åœæ­¢")
    return "end"
```

**æ¯ç« é¢„ä¼°èŠ‚ç‚¹æ¶ˆè€—ï¼ˆçº¦ 6 ä¸ªï¼‰ï¼š**
1. `chapter_generation` / `scene_generation_wrapper` - ç« èŠ‚/åœºæ™¯ç”Ÿæˆ
2. `consistency_check` - ä¸€è‡´æ€§æ£€æµ‹
3. `chapter_revision`ï¼ˆå¯é€‰ï¼‰- ç« èŠ‚ä¿®è®¢
4. `next_chapter` - é€’å¢ç« èŠ‚å·
5. æ¡ä»¶è¾¹æ‰§è¡Œï¼ˆ`should_*` å‡½æ•°ï¼‰
6. å®‰å…¨ä½™é‡

#### 2. ç¨‹åºå¡é¡¿ä¼˜åŒ–

**ä¿®æ”¹çš„æ–‡ä»¶ï¼š**
- `novelgen/runtime/mem0_manager.py` - æ·»åŠ è¶…æ—¶ä¿æŠ¤

**è¶…æ—¶ä¿æŠ¤æœºåˆ¶ï¼š**
```python
def close(self, timeout: float = 5.0):
    """å¸¦è¶…æ—¶ä¿æŠ¤çš„æ¸…ç†æ–¹æ³•"""
    import signal
    
    def timeout_handler(signum, frame):
        print(f"âš ï¸ Mem0 æ¸…ç†è¶…æ—¶ ({timeout}s)ï¼Œå¼ºåˆ¶é€€å‡º")
        os._exit(0)
    
    signal.signal(signal.SIGALRM, timeout_handler)
    signal.alarm(int(timeout))
    
    try:
        # å°è¯•æŒä¹…åŒ–æ•°æ®
        if hasattr(vs, 'persist'):
            vs.persist()
        # å°è¯•å…³é—­ ChromaDB
        if hasattr(chroma_client, 'close'):
            chroma_client.close()
    finally:
        signal.alarm(0)  # å–æ¶ˆè¶…æ—¶
```

### éªŒè¯æµ‹è¯•

```python
# è®¾ç½®æµ‹è¯•å‚æ•°
os.environ["LANGGRAPH_RECURSION_LIMIT"] = "50"
os.environ["LANGGRAPH_NODES_PER_CHAPTER"] = "6"

# æ¨¡æ‹Ÿ 45 æ¬¡æ‰§è¡Œå
state.node_execution_count = 45
remaining = 50 - 45  # = 5

# 5 < 6ï¼Œè§¦å‘ä¸»åŠ¨åœæ­¢
# âš ï¸ å‰©ä½™(5) < æ¯ç« éœ€è¦(6)ï¼Œåº”è¯¥ä¸»åŠ¨åœæ­¢
```

### ä¿®å¤æ•ˆæœ

| é—®é¢˜ | ä¿®å¤å‰ | ä¿®å¤å |
|------|--------|--------|
| GraphRecursionError | è¾¾åˆ°é™åˆ¶åå¼‚å¸¸é€€å‡º | é¢„ä¼°ä¸è¶³æ—¶ä¸»åŠ¨åœæ­¢ |
| æ£€æŸ¥ç‚¹ä¸ä¸€è‡´ | å¼‚å¸¸é€€å‡ºæ—¶æ£€æŸ¥ç‚¹æŸå | ä¸»åŠ¨åœæ­¢æ—¶æ­£ç¡®ä¿å­˜ |
| ç¨‹åºå¡é¡¿ | é€€å‡ºæ—¶ç­‰å¾… 3 åˆ†é’Ÿ | è¶…æ—¶ 5 ç§’åå¼ºåˆ¶é€€å‡º |

### ä¸ºä»€ä¹ˆä¸ç”¨ LangGraph çš„ RemainingStepsï¼Ÿ

LangGraph æä¾›äº† `RemainingSteps` æ³¨è§£ç”¨äºè·å–å‰©ä½™æ­¥æ•°ï¼Œä½†å®ƒåªèƒ½ç”¨äº `TypedDict` çŠ¶æ€ç±»å‹ã€‚
æœ¬é¡¹ç›®ä½¿ç”¨ **Pydantic BaseModel** ä½œä¸ºçŠ¶æ€ç±»å‹ï¼Œæ— æ³•ç›´æ¥ä½¿ç”¨æ­¤ç‰¹æ€§ã€‚

å› æ­¤é‡‡ç”¨**è‡ªç»´æŠ¤è®¡æ•°å™¨**æ–¹æ¡ˆï¼š
1. åœ¨çŠ¶æ€ä¸­æ·»åŠ  `node_execution_count` å­—æ®µ
2. æ¯ä¸ªèŠ‚ç‚¹æ‰§è¡Œæ—¶é€’å¢
3. åœ¨æ¡ä»¶è¾¹ä¸­æ£€æŸ¥å‰©ä½™æ¬¡æ•°
