## Context

阶段1已经实现了数据库和向量存储的基础持久化功能，包括SQLite数据库和ChromaDB向量存储的抽象接口。阶段2的目标是建立只读验证能力，重点在于完善查询接口，并通过基础 CLI 工具辅助人工验证数据设计的有效性。

**关键约束：**
- 阶段2必须保持只读性质，不能修改现有的生成流程
- 所有新增功能必须向后兼容，不影响现有系统
- 需要在现有db.py和vector_store.py架构基础上扩展
- 验证工具必须独立运行，不依赖LangChain功能调用

## Goals / Non-Goals

**Goals:**
- 提供完整的数据库和向量存储查询接口
- 创建易用的基础CLI查询工具（支持按项目/实体/场景查看状态与记忆）
- 提供数据库和向量存储的基础健康检查能力

**Non-Goals:**
- 修改现有的数据存储架构
- 实现数据修复或自动更正功能
- 集成到现有的生成流程中
- 创建Web UI或图形界面
- 实现实时监控或告警系统

## Decisions

### Decision: 采用分层验证架构
**选择：** 将验证功能分为四个独立层次：查询接口层、验证引擎层、CLI工具层、报告生成层。

**理由：**
- 每层职责单一，便于测试和维护
- 支持渐进式开发，可以先实现查询接口再添加验证功能
- CLI工具可以独立使用，不依赖验证流程
- 报告生成可以复用验证结果，避免重复计算

**替代方案考虑：**
- 单体验证脚本：开发简单但难以维护和扩展
- 微服务架构：过于复杂，不符合项目规模

### Decision: 使用独立脚本目录结构
**选择：** 创建`scripts/`目录存放所有验证和CLI工具，与`novelgen/`核心代码分离。

**理由：**
- 保持核心代码库的简洁性
- 验证工具可以独立部署和运行
- 便于未来扩展为独立的工具包
- 避免与现有业务逻辑产生耦合

**替代方案考虑：**
- 集成到`novelgen/runtime/`：会增加核心模块复杂度
- 放在项目根目录：会造成目录结构混乱

### Decision: 采用混合报告格式
**选择：** 同时支持Markdown和JSON格式的验证报告。

**理由：**
- Markdown格式便于人类阅读和文档集成
- JSON格式便于程序化处理和自动化分析
- 满足不同用户场景的需求
- 支持报告数据的二次处理和可视化

**替代方案考虑：**
- 仅Markdown：不利于自动化处理
- 仅JSON：人类阅读体验差
- HTML格式：开发复杂度高，维护成本大

### Decision: 实现增量验证模式
**选择：** 支持全量验证和增量验证两种模式。

**理由：**
- 全量验证确保数据完整性
- 增量验证提高执行效率，适合持续集成
- 支持不同场景的灵活使用
- 为未来的实时验证奠定基础

**替代方案考虑：**
- 仅全量验证：执行时间长，不适合频繁使用
- 仅增量验证：无法保证整体数据质量

## Risks / Trade-offs

### Risk: 查询接口性能影响
**风险：** 新增的查询方法可能影响现有数据库和向量存储的性能。

**缓解措施：**
- 所有查询方法都使用只读操作，不修改数据
- 实现查询结果缓存机制
- 添加查询超时和资源限制
- 在设计阶段进行性能基准测试

### Risk: 验证工具复杂度
**风险：** 验证功能可能变得过于复杂，难以维护。

**缓解措施：**
- 采用模块化设计，每个验证器独立
- 实现配置驱动的验证规则
- 提供详细的文档和使用示例
- 建立完善的单元测试覆盖

### Trade-off: 验证覆盖率 vs 执行效率
**权衡：** 更全面的验证检查需要更长的执行时间。

**决策：**
- 提供可配置的验证级别（快速/标准/全面）
- 支持选择性启用特定的验证项目
- 优化关键路径的查询性能
- 提供并行执行能力

### Trade-off: 功能丰富性 vs 易用性
**权衡：** 丰富的分析功能可能增加学习成本。

**决策：**
- 设计直观的CLI命令结构
- 提供详细的帮助文档和示例
- 实现智能默认配置
- 支持向导模式的交互式使用

## Migration Plan

### 阶段1：基础查询接口实现
1. 在`DatabaseInterface`和`VectorStoreInterface`中添加只读查询相关抽象方法
2. 在具体实现类中完成查询逻辑（例如SQLiteDatabase、ChromaVectorStore等）
3. 在`DatabaseManager`和`VectorStoreManager`中暴露对应包装方法（含`health_check`）
4. 添加单元测试验证功能正确性

### 阶段2：基础CLI与人工验证
1. 创建`scripts`目录结构并实现基础入口脚本
2. 实现`query-entity`命令，支持按project_id和entity_id查询最新状态
3. 实现`query-scene-memory`命令，支持按project_id + chapter_index + scene_index查询相关记忆块
4. 在真实或测试项目上手动运行上述命令，验证查询结果是否符合预期
5. 根据人工验证的反馈，在后续独立变更中视需要扩展数据质量验证框架或报告能力

**回滚计划：**
- 每个阶段都保持向后兼容
- 新增功能可以独立禁用
- 核心接口变更遵循语义化版本控制
- 提供配置开关控制功能启用

## Open Questions

1. **验证规则配置：** 是否需要支持YAML或JSON格式的验证规则配置文件？
2. **国际化支持：** CLI工具和报告是否需要支持英文输出？
3. **插件机制：** 是否需要设计插件机制支持自定义验证器？
4. **数据导出：** 是否需要支持将验证结果导出到外部系统（如数据库、API）？
5. **并发安全：** 验证工具是否需要支持与生成流程并发执行？

## Technical Considerations

### 依赖管理
- 最小化外部依赖，优先使用Python标准库
- 新增依赖必须与现有项目兼容
- 考虑在虚拟环境中隔离验证工具的依赖

### 错误处理
- 实现优雅的错误处理和恢复机制
- 提供详细的错误信息和调试支持
- 支持部分失败场景的继续执行

### 扩展性设计
- 预留接口支持未来的验证器扩展
- 设计灵活的配置系统支持定制化需求
- 考虑与未来监控和告警系统的集成可能性
